<HTML>
<HEAD>
  <!-- Created with AOLpress/2.0 -->
  <!-- AP: Created on: 27-Jan-2003 -->
  <!-- AP: Last modified: 21-Apr-2006 -->
  <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Shift_JIS">
<!--<TITLE>Creating the letter "o" - - consistant directions</TITLE>-->
    <TITLE>文字 "o" の作成――矛盾の無いパスの向き</TITLE>
  <LINK REL="icon" href="../fftype16.png">
  <LINK REL="stylesheet" TYPE="text/css" HREF="FontForge.css">
</HEAD>
<BODY>
<DIV id="in">
  <H1 ALIGN=Center>
<!--Tutorial #2 -->
    チュートリアル (その 2)
  </H1>
  <UL>
    <LI>
<!--  <A HREF="editexample.html#FontCreate">Font Creation</A>-->
      <A HREF="editexample.html#FontCreate">フォントの作成</A>
    <LI>
<!--  <A HREF="editexample.html#CharCreate">Creating a glyph (tracing outlines)</A>-->
      <A HREF="editexample.html#CharCreate">グリフの作成 (アウトラインのトレース) 法</A>
    <LI>
<!--  <A HREF="editexample2.html#Navigating">Navigating to other glyphs</A>-->
      <A HREF="editexample2.html#Navigating">他のグリフの呼び出し方</A>
    <LI>
<!--  <A HREF="editexample2.html#Creating-o">On to the next glyph (consistent
      directions)</A>-->
      <A HREF="editexample2.html#Creating-o">次のグリフに関して (矛盾のないパスの向き)</A>
    <LI>
<!--  <A HREF="editexample3.html#consistent-stems">Consistent serifs and stem
      widths</A>-->
      <A HREF="editexample3.html#consistent-stems">統一のとれたセリフとステムの太さ</A>
    <LI>
<!--  <A HREF="editexample4.html#accents">Building accented glyphs</A>-->
      <A HREF="editexample4.html#accents">アクセントつきグリフの組み立て方</A>
    <LI>
<!--  <A HREF="editexample4.html#ligature">Building a ligature</A>-->
      <A HREF="editexample4.html#ligature">合字の組み立て方</A>
    <LI>
<!--  <A HREF="editexample5.html#metrics">Examining metrics</A>-->
      <A HREF="editexample5.html#metrics">メトリックの確認法</A>
    <LI>
<!--  <A HREF="editexample5.html#Kerning">Kerning</A>-->
      <A HREF="editexample5.html#Kerning">カーニング</A>
    <LI>
<!--  <A HREF="editexample6.html#Variants">Glyph variants</A>-->
      <A HREF="editexample6.html#Variants">異体関係にあるグリフ</A>
    <LI>
<!--  <A HREF="editexample6.html#Marks">Anchoring marks</A>-->
      <A HREF="editexample6.html#Marks">アンカーマーク</A>
    <LI>
<!--  <A HREF="editexample6-5.html#Conditional">Conditional features</A>-->
      <A HREF="editexample6-5.html#Conditional">条件つき機能</A>
    <LI>
<!--  <A HREF="editexample7.html#checking">Checking your font</A>-->
      <A HREF="editexample7.html#checking">フォントのチェック法</A>
    <LI>
<!--  <A HREF="editexample7.html#generating">Generating it</A>-->
      <A HREF="editexample7.html#generating">フォントの出力方法</A>
    <LI>
<!--  <A HREF="editexample7.html#Families">Font Families</A>-->
      <A HREF="editexample7.html#Families">フォントファミリー</A>
    <LI>
<!--  <A HREF="editexample7.html#summary">Final Summary</A>-->
      <A HREF="editexample7.html#summary">最後のまとめ</A>
    <LI>
<!--  <A HREF="scripting-tutorial.html">Scripting Tutorial</A> -->
      <A HREF="scripting-tutorial.html">スクリプト処理のチュートリアル</A>
    <LI>
<!--  <A HREF="scriptnotes.html#Special">Notes on various scripts</A>-->
      <A HREF="scriptnotes.html#Special">各種の用字系における注意点</A>
  </UL>
  <H2>
<!--<A NAME="Navigating">Navigating to glyphs.</A>-->
    <A NAME="Navigating">グリフの呼び出し方</A>
  </H2>
  <P>
<!--
  The font view provides one way of navigating around the glyphs in a font.
  Simple scroll around it until you find the glyph you need and then double
  click on it to open a window looking at that glyph. -->
  フォントビュー (表示画面) は、フォント内のグリフを呼び出すための一つの方法を提供します。単純に、あなたが必要とするグリフがみつかるまで画面をスクロールしてから、そのグリフをダブルクリックして、グリフを見るためのウィンドウを開いてください。
  <P>
<!--
  Typing a glyph will move to that glyph. -->
  文字をタイプすれば、その文字に割り当てられたグリフに移動します。
  <P>
<!--
  However some fonts are huge (Chinese, Japanese and Korean fonts have thousands
  or even tens of thousands of glyphs) and scrolling around the font view is
  a an inefficient way of finding your glyph. <CODE>View-&gt;Goto </CODE>provides
  a simple dialog which will allow you to move directly to any glyph for which
  you know the name (or encoding). If your font is a Unicode font, then this
  dialog will also allow you to find glyphs by block name (ie. Hebrew rather
  than Alef). -->
  しかしながらある種のフォントは巨大で (中国語や日本語・韓国語のフォントは数千から数万字にも及ぶグリフを含みます) フォントビューをスクロールして回るのはグリフを探す方法としては非効率です。<CODE>表示(<U>V</U>)</CODE>→<CODE>移動(<U>G</U>)</CODE> を実行するとダイアログが表示され、そこでグリフの名前 (または文字符号) を入力すれば、目的の文字に直接移動することができます。あなたのフォントが Unicode フォントであるなら、グリフを探すときにこのダイアログにブロック名を入力することができます (例: Alef でなく Hebrew と入力できる)。
  <P>
<!--
  The simplest way to navigate is just to go to the next or previous glyph.
  And <CODE>View-&gt;Next Char</CODE> and <CODE>View-&gt;Prev Char</CODE> will
  do exactly that. -->
  いちばん単純な呼び出し方法は、前後の文字に移動することです。これらの操作は、<CODE>表示(<U>V</U>)</CODE>→<CODE>次のグリフ(<U>N</U>)</CODE> と <CODE>表示(<U>V</U>)</CODE>→<CODE>前のグリフ(<U>P</U>)</CODE> でできます。
  <H2>
<!--<A NAME="Creating-o">Creating </A>the letter "o" - - consistent directions -->
    文字“o”の <A NAME="Creating-o">作成</A>――矛盾の無いパスの向き
  </H2>
  <P>
<!--
  In the previous example the bitmap of the letter filled the canvas of the
  image. And when FontForge imported the image it needed to be scaled once
  in the program. But usually when you create the image of the letter you have
  some idea of how much white space there should be around it. If your images
  are exactly one em high then FontForge will scale them automatically to be
  the right size. So in the following examples all the images have exactly
  the right amount of white-space around them to fit perfectly in an em. -->
  さきほどの例では、文字のビットマップは画像の大きさいっぱいに描かれていました。そのため FontForge に画像を取り込んだ時、最初にプログラム内で拡大/縮小を行う必要がありました。しかし一般的には、文字の画像を作成する時には、その周りにどれだけの空白を置くかをあらかじめ想定しているのがふつうです。画像の高さがちょうど全角 (em) に等しい場合、FontForge は正しいサイズに自動的に拡大/縮小します。これ以降の例では、全ての画像は、全角にぴったり一致するだけの空白を文字の周りに含んでいるものとします。
  <P>
<!--
  For the next example double click on the square in the font view that should
  contain "o", and import "o_Ambrosia.png" into it. -->
  次の例を表示するには、フォントビュー内で“o”を含んでいるマスをダブルクリックして“o_Ambrosia.png”を取り込んでください。
  <TABLE BORDER CELLPADDING="2">
    <CAPTION>
<!--  Stages in editing "o" -->
      文字“o”の編集の各段階
    </CAPTION>
    <TR>
      <TD><IMG SRC="../o1.png" WIDTH="190" HEIGHT="287"></TD>
      <TD><IMG SRC="../o2.png" WIDTH="190" HEIGHT="287"></TD>
      <TD><IMG SRC="../o3.png" WIDTH="190" HEIGHT="287"></TD>
      <TD><IMG SRC="../o4.png" WIDTH="190" HEIGHT="287"></TD>
    </TR>
  </TABLE>
  <P>
<!--
  Notice that the first outline is drawn clockwise and the second
  counter-clockwise. This change in drawing direction is important. Both PostScript
  and TrueType require that the outer boundary of a glyph be drawn in a certain
  direction (they happen to be opposite from each other, which is a mild
  annoyance), within FontForge all outer boundaries must be drawn clockwise,
  while all inner boundaries must be drawn counter-clockwise. -->
  最初のアウトラインは時計回りに、2 番目を反時計回りに描かれていることに注意してください。PostScript・TrueTypeのどちらにおいてもグリフの輪郭は特定の向きに描かれなくてはならないことに決まっており (ちょっと面倒なことに、これらは互いに逆方向になっています)、FontForge では外側の輪郭線はすべて時計回りに、内側の輪郭線はすべて反時計回りでなくてはなりません。
  <P>
<!--
  If you fail to alternate directions between outer and inner boundaries you
  may get results like the one on the left
  <IMG SRC="o-baddir.png" WIDTH="51" HEIGHT="28">. If you fail to draw the
  outer contour in a clockwise fashion the errors are more subtle, but will
  generally result in a less pleasing result once the glyph has been rasterized. -->
  外側の輪郭と内側の輪郭を逆向きにするのを忘れた場合、この図 <IMG SRC="../o-baddir.png" WIDTH="51" HEIGHT="28"> の左側のような結果が得られるでしょう。外側を時計回りにするということを忘れた場合は、エラーはもっと軽微なものですが、それでも一般的には、グリフをラスタライズする必要が生じた時にあまり愉快ではない結果が得られるでしょう。
  <P>
<!--
  <SMALL><STRONG>TECHNICAL AND CONFUSING</STRONG>: the exact behavior of
  rasterizers varies. Early PostScript rasterizers used a "non-zero winding
  number rule" while more recent ones use an "even-odd" rule. TrueType uses
  the "non-zero" rule. The description given above is for the "non-zero" rule.
  The "even-odd" rule would fill the "o" correctly no matter which way the
  paths were drawn (though there would probably be subtle problems with
  hinting).</SMALL> -->
  <SMALL><STRONG>技術的で分かりにくい事柄</STRONG>: ラスタライザの正確なふるまいは様々です。初期の PostScript ラスタライザは「非ゼロ巻き数ルール」を使っていましたが、最近のものは「奇偶ルール」を使います。TrueType は「非ゼロルール」です。上で行った説明は「非ゼロルール」です。「奇偶ルール」の場合、パスがどちら向きであっても問題なく“o”は正確に表示されます (ただしヒント処理のときに微妙な問題をひき起こすでしょう)。</SMALL>
  <P>
<!--
  <SMALL>Filling using the <A NAME="even-odd">even-odd </A>rules that a line
  is drawn from the current pixel to infinity (in any direction) and the number
  of contour crossings is counted. If this number is even the pixel is not
  filled. If the number is odd the pixel is filled. In the
  <A NAME="non-zero">non-zero </A>winding number rule the same line is drawn,
  contour crossings in a clockwise direction add 1 to the crossing count,
  counter-clockwise contours subtract 1. If the result is 0 the pixel is not
  filled, any other result will fill it.</SMALL> -->
  <SMALL><A NAME="even-odd">奇偶</A>ルールを用いた塗りつぶしは、現在のピクセルから (任意の方向に) 直線を引き、輪郭線と交差する回数を数えるというものです。この回数が偶数なら、ピクセルは塗りつぶしません。回数が奇数ならピクセルを塗りつぶします。<A NAME="non-zero">非ゼロ</A>巻き数ルールでも同じ線を引きます。時計回りの輪郭線と交差するたびに交差回数に 1 を加え、反時計回りの線に交差するたびに 1 を引きます。結果が 0 ならば、ピクセルは塗りつぶさず、それ以外の値ならば塗りつぶします。</SMALL>
  <P>
<!--
  The command <CODE><A HREF="elementmenu.html#Correct">Element-&gt;Correct
  Direction</A></CODE> will look at each selected contour, figure out whether
  it qualifies as an outer or inner contour and will reverse the drawing direction
  when the contour is drawn incorrectly. -->
  <A HREF="elementmenu.html#Correct"><CODE>エレメント(<U>L</U>)</CODE>→<CODE>アウトラインの向きを修正(<U>C</U>)</A></CODE> コマンドは、選択された各輪郭を眺め、それが外側になるか内側になるかを判断し、輪郭線が間違って逆向きに描かれている場合にはその向きを逆転させます。
  <P>
  <P ALIGN=Center>
  ― <A HREF="editexample.html">前</A> ― <A HREF="overview.html">目次</A>
  ― <A HREF="editexample3.html">次</A> ―
</DIV>
</BODY></HTML>
